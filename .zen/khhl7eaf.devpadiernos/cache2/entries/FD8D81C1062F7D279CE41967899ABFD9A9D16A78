/**
 * Frontend scripting for the animated hero block.
 */

class AnimatedHero {
    media;
    canvas;
    canvasContext;
    video;

    _bgImages = [];

    _textPaneBottom;
    _totalBlockHeight;
    _visibleBlockHeight;
    _currentBreakpoint;
    _isShowingCanvas = true;
    /** @type {Breakpoint} */
    _xxlBreakpoint; // Unique breakpoint for this block.

    constructor(element) {
        this.element = element;
        this.media = this.element.querySelector('.media');
        this.canvas = this.media.querySelector('canvas');
        this.video = this.media.querySelector('video');
        this.textPane = this.element.querySelector('.text-pane');
        this.buttons = this.textPane.querySelectorAll('.button');

        this.canvasContext = this.canvas.getContext('2d');

        this._xxlBreakpoint = new Breakpoint('XXL', 2560, Infinity);

        this._onResize();
        this._updateTextPaneEffects();

        Breakpointer.initialisedEvent.addListener((breakpoint) => this._onBreakpointChanged(breakpoint));
        Breakpointer.breakpointChangedEvent.addListener((breakpoint) => this._onBreakpointChanged(breakpoint));
        ThemeManager.themeChangedEvent.addListener(() => this._setVideoSrc());

        document.addEventListener('scroll', () => {
            this._updateTextPaneEffects();
            this.updateAnimation();
        });

        window.addEventListener('resize', () => this._onResize());

        if (this.buttons.length) {
            Breakpointer.breakpointChangedEvent.addListener((newBreakpoint) => {
                const sizeClass = newBreakpoint.gteq(Breakpoint.LG) ? 'lg' : 'md';
                for (const button of this.buttons) {
                    button.classList.remove('xl', 'lg', 'md', 'sm');
                    button.classList.add(sizeClass);
                }
            });

            if (this.textPane.querySelector('.button.user')) {
                const buttons = this.textPane.querySelectorAll(window.user ? '.button:not(.user)' : '.button.user');
                for (const button of buttons) {
                    button.remove();
                }
            }

            for (const button of this.textPane.querySelectorAll('.button')) {
                button.classList.remove('hidden');
            }
        }
    }

    updateAnimation() {
        // No jQuery here for performance on scroll listener

        const imageCount = this._bgImages.length;
        // Ensure the final image is displayed while the block is still in full view, before switching to the video.
        const pixelsPerImage = (this._totalBlockHeight - this._visibleBlockHeight) / imageCount;
        const imageIndex = Math.floor(window.scrollY / pixelsPerImage);
        // Transition from image sequence to video when end of sequence reached
        const transitionReached = imageIndex > imageCount - 1;

        if (transitionReached) {
            if (this._isShowingCanvas && this.video.readyState >= this.video.HAVE_CURRENT_DATA) {
                // Hide canvas, show video and play it
                this.media.classList.add('show-video');
                this.video.play();
                this._isShowingCanvas = false;
            }
        }
        else {
            // Show canvas if not already visible, hide and rewind video
            if (!this._isShowingCanvas) {
                if (this.video.readyState >= this.video.HAVE_METADATA) {
                    this.video.pause();
                    this.video.currentTime = 0;
                }

                this.media.classList.remove('show-video');
                this._isShowingCanvas = true;
            }

            this._setBgImage(Math.min(imageIndex, imageCount - 1));
        }
    }

    _onResize() {
        this._updateSizeValues();
        this._onBreakpointChanged(Breakpointer.currentBreakpoint);
    }

    _onBreakpointChanged(newBreakpoint) {
        if (window.innerWidth > this._xxlBreakpoint.min) {
            // Arbitrary but reasonable spacing tweak for the different media at XXL.
            this.element.style.marginBottom = `${this.canvas.height / -4}px`;
            newBreakpoint = this._xxlBreakpoint;
        }
        else {
            this.element.style.marginBottom = 'calc(var(--spacing-12) * -1)';
        }

        // Only fetch larger media - no point fetching smaller if we've already fetched larger
        // (except if the current breakpoint is the special XXL breakpoint as the media is different)
        if (this._currentBreakpoint
                && this._currentBreakpoint.gteq(newBreakpoint)
                && this._currentBreakpoint.lt(this._xxlBreakpoint)) {
            this.updateAnimation();
            return;
        }

        this._currentBreakpoint = newBreakpoint;

        this._prefetchImages();
        this._setVideoSrc();
        this.updateAnimation();
    }

    _updateSizeValues() {
        this._textPaneBottom = this.textPane.offsetTop - this.textPane.parentElement.offsetTop + this.textPane.clientHeight;
        this._totalBlockHeight = this.element.scrollHeight;
        this._visibleBlockHeight = this.media.clientHeight;
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
    }

    _getImageSrcs(breakpoint) {
        const srcs = [];

        const mediaPath = this.media.dataset.mediaPath;
        const breakpointName = breakpoint.name.toLowerCase();

        for (let i = 0; i <= 60; i++) {
            const number = i.toString().padStart(2, '0');
            srcs.push(`${mediaPath}/bgimg-${breakpointName}/${number}.png`);
        }

        return srcs;
    }

    _prefetchImages() {
        const imageSrcs = this._getImageSrcs(this._currentBreakpoint);

        for (let i = 0; i < imageSrcs.length; i++) {
            const image = new Image();
            image.onload = () => {
                // Image for the current step may have been loading, so update animation
                this.updateAnimation();
            }
            image.src = imageSrcs[i];
            this._bgImages[i] = image;
        }
    }

    _setVideoSrc() {
        this.video.pause();
        this.video.onloadeddata = () => this.updateAnimation();
        const mediaPath = this.media.dataset.mediaPath;
        const breakpointName = this._currentBreakpoint.name.toLowerCase();

        const ua = window.navigator.userAgent.toLowerCase();
        const isAndroid = ua.indexOf('android') !== -1; //Mobile Android
        const isDesktopSafari = (ua.indexOf('safari') !== -1) && (!(ua.indexOf('chrome') !== -1) && (ua.indexOf('version/') !== -1) && (ua.indexOf('mac os') !== -1)); //Desktop Safari on Mac OS
        const isMobileOS = (ua.indexOf('safari') !== -1) && (ua.indexOf('mobile') !== -1) && (ua.indexOf('mac os') !== -1); //Mobile Apple device (FF,chrome,safari)

        if (isAndroid) {
            this.video.src = `${mediaPath}/video/${breakpointName}.webm`;
        }
        else if (isMobileOS) {
            this.video.src = `${mediaPath}/video/${breakpointName}.mov`;
        }
        else if (isDesktopSafari) {
            this.video.src = `${mediaPath}/video/${breakpointName}.mov`;
        }
        else {
            // windows/linux/chrome based desktop
            this.video.src = `${mediaPath}/video/${breakpointName}.webm`;
        }

        this.video.load();
    }

    _setBgImage(index) {
        const image = this._bgImages[index];
        if (!image || !image.complete || image.naturalWidth === 0) return; // Not yet loaded or errored; don't update canvas

        const hRatio = this.canvas.width / image.width;
        const vRatio = this.canvas.height / image.height;
        const ratio = Math.max(hRatio, vRatio);
        const centreShiftX = (this.canvas.width - image.width * ratio) / 2;
        const centreShiftY = (this.canvas.height - image.height * ratio) / 2;

        this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.canvasContext.drawImage(image,
            0, 0, image.width, image.height, // Source rectangle of image
            centreShiftX, centreShiftY, image.width * ratio, image.height * ratio); // Destination rectangle in canvas
    }

    _updateTextPaneEffects() {
        // Transition text-pane transparency as it is scrolled out of view
        let positionMultiplier = Math.min(Math.max(window.scrollY / this._textPaneBottom, 0), 1); // 0: in centre => 1: out of view
        positionMultiplier -= 0.2; // Start transitioning at 20% progress
        const gradientStart = positionMultiplier * 1.5 * 100; // in percent
        const gradientEnd = gradientStart + (positionMultiplier * 100);
        const topOpacity = Math.max(1 - (positionMultiplier * 4), 0.15);

        this.textPane.style.maskImage = `linear-gradient(
            rgba(0, 0, 0, ${topOpacity}) ${gradientStart}%,
            rgba(0, 0, 0, 1) ${gradientEnd}%,
            rgba(0, 0, 0, 1))`;

        const blur = Math.min(Math.max(positionMultiplier - 0.1, 0) * 10); // Delay start of blur effect by extra 10% progress
        this.textPane.style.filter = `blur(${blur}px)`;
    }
}
˚KIl      hThTHPõèh{ô   ç    O^userContextId=1&partitionKey=%28https%2Cmega.io%29,:https://mega.io/wp-content/themes/megapages/blocks/animated-hero/view.js?ver=1746139673 strongly-framed 1 security-info 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 request-method GET response-head HTTP/2 200 
server: nginx
date: Thu, 19 Jun 2025 13:09:45 GMT
content-type: application/javascript
content-length: 9162
last-modified: Thu, 01 May 2025 22:47:53 GMT
etag: "6813fa19-23ca"
expires: Mon, 30 Jun 2025 23:13:59 GMT
cache-control: max-age=2592000, max-age=2592000
x-cache-status: HIT
accept-ranges: bytes
X-Firefox-Spdy: h2
 original-response-headers server: nginx
date: Thu, 19 Jun 2025 13:09:45 GMT
content-type: application/javascript
content-length: 9162
last-modified: Thu, 01 May 2025 22:47:53 GMT
etag: "6813fa19-23ca"
expires: Mon, 30 Jun 2025 23:13:59 GMT
cache-control: max-age=2592000
cache-control: max-age=2592000
x-cache-status: HIT
accept-ranges: bytes
X-Firefox-Spdy: h2
 ctid 2 uncompressed-len 0 net-response-time-onstart 675 net-response-time-onstop 855   # 