/**
 * Scripting for MEGA Pages.
 */

/**
 * If megapages is loaded with a GET parameter affiliate ID set, save it to session storage and
 * update webclient link targets with the affiliate ID, to pass it on.
 */
class AffiliateLinker {
    validPeriod = 86400 * 30; // affiliate ID valid for 30 days (in seconds)

    constructor() {
        this.setIdFromCurrentUrl();
        this.updateWebclientTargets();
    }

    /**
     * Check current URL for an affiliate ID GET parameter and save it to local storage.
     */
    setIdFromCurrentUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('aff')) {
            Storage.local.setItem('affiliate', JSON.stringify({
                id: urlParams.get('aff'),
                ts: Math.floor(Date.now() / 1000), // seconds
            }));
        }
    }

    /**
     * Try to get the affiliate ID from local storage. If the ID doesn't exist or
     * is older than the {@link validPeriod}, return undefined.
     *
     * @returns {string|undefined} affiliate ID string or undefined if not valid.
     */
    tryGetIdFromStorage() {
        let affiliate = Storage.local.getItem('affiliate');
        try {
            affiliate = JSON.parse(affiliate);
        }
        catch (e) {
            console.error("Couldn't parse affiliate data.");
            console.trace(e, affiliate);
            return;
        }

        // Check ID exists
        if (!affiliate || !affiliate.id) return;

        // If date exists check expiry
        if (affiliate.ts && Math.floor(Date.now() / 1000) - affiliate.ts > this.validPeriod) {
            // Remove expired affiliate data
            Storage.local.removeItem('affiliate');
            return;
        }

        return affiliate.id;
    }

    /**
     * Update all webclient link targets with the affiliate ID saved in session storage, if it exists.
     */
    updateWebclientTargets() {
        const affiliateId = this.tryGetIdFromStorage();
        if (!affiliateId) return;

        for (const [a, url] of LinkManager.getWebclientLinks().entries()) {
            url.searchParams.set('aff', affiliateId);
            a.href = url.href;
        }
    }
}

/** External affiliate service */
class CjAffiliateLinker {
    validPeriod = 86400 * 30; // event ID valid for 30 days (in seconds)

    constructor() {
        this.setIdFromCurrentUrl();
        this.updateWebclientTargets();
    }

    /** Check current URL for a CJ event ID GET parameter and save it to local storage. */
    setIdFromCurrentUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('cjevent')) {
            Storage.local.setItem('cj.event', JSON.stringify({
                id: urlParams.get('cjevent'),
                ts: Math.floor(Date.now() / 1000), // seconds since Epoch
            }));
        }
    }

    /**
     * Try to get the event ID from local storage. If the ID doesn't exist or
     * is older than the {@link validPeriod}, return undefined.
     *
     * @returns {string|undefined} event ID string or undefined if not valid.
     */
    tryGetIdFromStorage() {
        let event = Storage.local.getItem('cj.event');
        try {
            event = JSON.parse(event);
        }
        catch (e) {
            console.error("Couldn't parse affiliate data.");
            console.trace(e, event);
            return;
        }

        // Check ID exists
        if (!event || !event.id) return;

        // If date exists check expiry
        if (event.ts && Math.floor(Date.now() / 1000) - event.ts > this.validPeriod) {
            // Remove expired event data
            Storage.local.removeItem('cj.event');
            return;
        }

        return event.id;
    }

    /** Update all webclient link targets with the affiliate ID saved in session storage, if it exists. */
    updateWebclientTargets() {
        const eventId = this.tryGetIdFromStorage();
        if (!eventId) return;

        for (const [a, url] of LinkManager.getWebclientLinks().entries()) {
            url.searchParams.set('cjevent', eventId);
            a.href = url.href;
        }
    }
}

class Discounts {
    constructor() {
        this._discounts = { };
        this._discountPromises = { };
    }

    /** @returns {Discounts} */
    static get instance() {
        if (!Discounts._instance) {
            Discounts._instance = new Discounts();
        }

        return Discounts._instance;
    }

    /**
     * Fetch the {@see Discount} info (or otherwise the API response) for the given code from the API.
     *
     * @param code Discount URL slug name for a given discount
     * @returns {Promise<*>}
     */
    async get(code) {
        if (!code) return null;

        if (!this._discounts[code]) {
            // Reuse promises to avoid duplicate requests
            this._discountPromises[code] ||= this._fetchAndParse(code);
            const discount = await this._discountPromises[code];
            delete this._discountPromises[code];

            return discount;
        }

        return this._discounts[code];
    }

    /**
     * Fetch the {@linkcode Discount} info (or otherwise the API response) for the given code from the API.
     * The associated {@linkcode Plan} info will be attached to the {@linkcode Discount} object as field "plan".
     *
     * @param {string} code
     * @returns {Promise<*|null>}
     */
    async getWithPlan(code) {
        if (!code) return null;

        const [discount, plans] = await Promise.all([Discounts.instance.get(code), Plans.instance.getAll()]);

        if (discount instanceof Discount) {
            const plan = plans.find(plan => plan.accountLevel === discount.accountLevel);
            discount.plan = plan instanceof Plan ? plan : null;
        }

        return discount;
    }

    async _fetchAndParse(code) {
        const discountInfo = await this._fetch(code);
        if (!discountInfo || typeof discountInfo !== 'object') {
            return discountInfo;
        }

        this._discounts[code] = Discount.fromResponse(discountInfo); // Only cache successful responses

        return this._discounts[code];
    }

    async _fetch(code) {
        const request = Api.request({
            a: 'dci',
            dc: null,
            extra: true,
            su: code,
        });

        let response;
        try {
            response = await request;
        }
        catch (e) {
            console.error(`API discount information request for code '${code}' failed.`, e.message);
            return null;
        }

        if (typeof response !== 'object') {
            console.error(`API discount information request for code '${code}' failed.`, ApiErrors.getMessage(response) || response);
        }

        return response;
    }
}

class Discount {
    get planName() {
        return Plans.Names[this.accountLevel];
    }

    static fromResponse(response) {
        const discount = new Discount();

        discount.accountLevel = response.al; // Account Level
        discount.durationMonths = response.m; // Months
        discount.discountPercentage = response.pd; // Percent Discount
        /** Timestamp of when the discount offer expires */
        discount.expiryTimestamp = response.ex;
        /** Whether the user will be charged the normal plan price when the discount period ends */
        discount.compulsorySubscription = response.cs; // Compulsory Subscription
        /** Whether the discount code can be used multiple times */
        discount.multiUse = response.md // Multi-use Discount

        discount.euro = { };
        discount.euro.undiscountedPrice = response.etp; // Euro Total Price (undiscounted)
        discount.euro.discountedPrice = response.edtp; // Euro Discounted Total Price
        discount.euro.discountedAmount = response.eda // Euro Discount Amount (amount saved)

        discount.local = { };
        discount.local.undiscountedPrice = response.ltp; // Local Total Price (undiscounted)
        discount.local.discountedPrice = response.ldtp; // Local Discounted Total Price
        discount.local.discountedAmount = response.lda; // Local Discounted Amount (amount saved)

        return discount;
    }
}

/**
 * Singleton to manage MEGA job listings.
 * @see JobListing
 */
class JobListings {
    static _instance;

    _jobs;
    _fetchPromise;

    static get instance() {
        if (!JobListings._instance) {
            JobListings._instance = new JobListings();
        }

        return JobListings._instance;
    }

    /**
     * Get all job listings. Will fetch from API first if not already fetched.
     * Returns a promise.
     */
    async getAll() {
        if (this._jobs == null) {
            await this.fetchFromApi();
        }

        return this._jobs || [];
    }

    /**
     * Asynchronously set the jobs array with data from the API.
     * Returns a promise.
     */
    async fetchFromApi() {
        if (!this._fetchPromise) {
            this._fetchPromise = Api.request({
                a: 'ttfj',
            });
        }

        let response;
        try {
            response = await this._fetchPromise;
        }
        catch (e) {
            console.error('Couldn\'t request job listings from API.', e.message);
            return;
        }

        if (!Array.isArray(response)) {
            console.error('API response to job listings request is something unexpected.');
            return;
        }

        this._jobs = [];
        for (let i = 1; i < response.length; i++) {
            const jobData = response[i];
            if (jobData.length < 5) {
                console.warn('Unexpected job data instance from API response: Not enough fields.');
                continue;
            }

            this._jobs.push(new JobListing(jobData[0], jobData[1], jobData[2], jobData[3], jobData[4]));
        }
    }
}

/**
 * Instance of a MEGA job listing.
 * @see JobListings
 */
class JobListing {
    id;
    jobTitle;
    jobField;
    description;
    url;

    constructor(id, jobTitle, jobField, description, url) {
        this.id = id;
        this.jobTitle = jobTitle;
        this.jobField = jobField;
        this.description = description;
        this.url = url;
    }
}

class User {
    /** See webclient/css/avatars.css */
    static _webclientColourStylesCount = 12;

    _firstName;
    _avatar;
    _avatarColourKey;
    _planNum;

    /**
     * @param {string} firstName
     * @param {string} avatar
     * @param {int} planNum
     * @param {int} avatarColourKey
     */
    constructor(firstName, avatar, planNum, avatarColourKey) {
        this._firstName = firstName || '';
        this._avatar = avatar || '';
        this._avatarColourKey = parseInt(avatarColourKey) || 1;
        this._planNum = parseInt(planNum) || -1;

        // Check the avatar colour key is in range of available styles
        if (this._avatarColourKey < 1 || this._avatarColourKey > User._webclientColourStylesCount) {
            this._avatarColourKey = 1;
        }
    }

    /**
     * Get the first name of the user.
     *
     * @returns {String} user's first name
     */
    get name() {
        return this._firstName
    };

    /**
     * Get the base64-encoded custom avatar of the user, if it exists.
     * Otherwise, consider using {@link avatarColourKey}.
     *
     * @returns {String} user's base64-encoded avatar
     */
    get avatar() {
        return this._avatar;
    }

    /**
     * Get the webclient-generated avatar colour class of this user.
     * Defaults to "color1" if the real colour key is not available.
     * Consider using {@link avatar} if possible.
     *
     * @returns {String}
     */
    get avatarColourKey() {
        return `color${this._avatarColourKey}`;
    }

    /**
     * Get the identifying number of the user's MEGA plan.
     *
     * @returns {Number}
     */
    get planNum() {
        return this._planNum;
    }
}

/**
 * Automatically pause videos when not in view or tab loses focus, for performance.
 * Intended for video animations. Particularly beneficial for Firefox.
 */
class VideoPauser {
    constructor() {
        this._onObserve = this._onObserve.bind(this);
        this._onVisibilityChanged = this._onVisibilityChanged.bind(this);

        this.visibleVideos = new Set();
        this.observer = new IntersectionObserver(this._onObserve);

        document.addEventListener('visibilitychange', this._onVisibilityChanged);
    }

    /** @returns {VideoPauser} */
    static get instance() {
        if (!VideoPauser._instance) {
            VideoPauser._instance = new VideoPauser();
        }

        return VideoPauser._instance;
    }

    /** @param {HTMLVideoElement} video */
    registerVideo(video) {
        // Only target video animations
        if (video.loop) {
            this.observer.observe(video);
        }
    }

    _onObserve(observables) {
        for (const observable of observables) {
            if (observable.isIntersecting) {
                this.visibleVideos.add(observable.target);
                this._tryPlay(observable.target);
            }
            else {
                this.visibleVideos.delete(observable.target);
                observable.target.pause();
            }
        }
    }

    _onVisibilityChanged() {
        if (document.hidden) {
            for (const video of this.visibleVideos) {
                video.pause();
            }
        }
        else {
            for (const video of this.visibleVideos) {
                this._tryPlay(video);
            }
        }
    }

    async _tryPlay(video) {
        try {
            await video.play();
        }
        catch (e) {
            if (e instanceof DOMException &&
                (e.message.includes('play() request was interrupted')
                    || e.message.includes('media resource was aborted by the user'))) {
                // Video pause requested before async play could fulfil, this is fine
                // (e.g. still loading while video is scrolled out of view)
                return;
            }
            if (e.name !== 'AbortError') {
                throw e;
            }
        }
    }
}

function setListNumber() {
    for (const ol of document.querySelectorAll('.page-container ol')) {
        ol.querySelector('li').style.counterIncrement = `item ${ol.start}`;
    }
}

(() => {
    ThemeManager.registerThemes(['light', 'dark']);

    LanguageRedirector.redirect();
    if (!LanguageRedirector.isRedirecting) { // avoid duplicate logs
        CampaignTagger.init();
    }

    if (Storage.session.getItem('userFirstName')) {
        window.user = new User(
            Storage.session.getItem('userFirstName'),
            Storage.session.getItem('userAvatar'),
            parseInt(Storage.session.getItem('userPlanNum')),
            parseInt(Storage.session.getItem('userAvatarColourKey')),
        );
    }
})();

document.addEventListener('DOMContentLoaded', () => {
    console.log('Page loaded. Initializing scripting.');

    if (document.documentElement.dir === 'rtl') {
        $('.button .icon.arrow-right-mro').addClass('arrow-left-mro').removeClass('arrow-right-mro');
        $('.text-button .icon.arrow-right-mro').addClass('arrow-left-mro').removeClass('arrow-right-mro');
    }

    CampaignTracker.init();

    window.affiliateLinker = new AffiliateLinker();
    window.cjAffiliateLinker = new CjAffiliateLinker();
    window.overlay = new Overlay($('body > .overlay.standard'));
    window.overlayWithHeader = new Overlay($('body > .overlay.with-header'));
    window.mobileNavMenu = new MobileMenuModal(document.querySelector('.mobile-modals .nav-menu'));
    window.header = new Header(document.querySelector('body > header.site-header'));
    window.footer = new Footer(document.querySelector('body > footer.site-footer'));
    window.cookieBanner = new CookieBanner(document.querySelector('body > dialog.cookie-banner'));

    if (window.user) {
        window.header.setAccountBtnsVisibility(false);
        window.mobileNavMenu.setAccountBtnsVisibility(false);

        if (window.user.avatar) {
            const ab = Utils.base64ToAb(window.user.avatar);
            const blob = new Blob([ab], { type: 'image/jpeg' });
            const url = window.URL.createObjectURL(blob);

            window.header.setCustomAvatar(url);
        }
        else {
            window.header.setAvatar(window.user.name, window.user.avatarColourKey);
        }

        // Remove Achievements and Pricing links from footer if user is on a Business/Pro Flexi plan
        if (window.user.planNum === Plans.AccountLevels.Business || window.user.planNum === Plans.AccountLevels.ProFlexi) {
            $('footer.site-footer a[href*="/achievements"], footer.site-footer a[href*="/pricing"]').remove();
        }
    }

    // Modals used across multiple pages
    const modals = ModalRegister.modalContainer;
    ModalRegister.registerModal(new LanguageSwitcher(modals.querySelector('.modal.language-switcher')));
    ModalRegister.registerModal(new CookieDialog(modals.querySelector('.modal.cookie-dialog')));

    setListNumber();

    // init MEGA custom blocks
    const pageContainer = document.querySelector('.page-container');
    if (pageContainer) {
        const selectorClassMap = {
            'section.activate-s4': () => ActivateS4,
            '.downloads-dropdown': () => DownloadsDropdown,
            '.feature-accordion': () => FeatureAccordion,
            '.feature-alternating': () => FeatureAlternating,
            '.feature-cards': () => SolutionsCards,
            '.feature-columns': () => FeatureColumns,
            '.hero-section': () => HeroSection,
            '.animated-hero': () => AnimatedHero,
            '.toc-group': () => Toc,
            '.product-comparison': () => ProductComparison,
            '.single-slice': () => SingleSlice,
            '.social-proof': () => SocialProof,
            '.competitor-matrix .matrix-card': () => CompetitorMatrixCard,
            'section.pro-flexi-business-pricing': () => ProFlexiBusinessPricing,
            '.pricing-table.individual': () => ProPlanCards,
            '.features-table': () =>  PricingFeaturesTable,
            '.open-source-module': () => OpenSource,
            '.leadership-team-list': () =>  LeadershipTeamList,
            '.counter-module': () => CounterModule,
            'section.timeline': () => Timeline,
            '.business-page-pricing-module': () => BusinessPagePricing,
            '.refer-calculator': () => ReferCalculator,
            '.home-social-proof': () => HomeSocialProof,
            '.full-width-banner': () => FullWidthBanner,
            '.bottom-cta': () => BottomCTA,
            'section.appeal-form': () => AppealFormBlock,
            'section.copyright-notice': () => CopyrightNotice,
            'section.currency-selector': () => CurrencySelector,
            'section.discount-banner': () => DiscountBanner,
            'section.discount-hero': () => DiscountHero,
            'section.package-downloads': () => PackageDownloads,
            'section.s4-ryi': () => S4Ryi,
            'section.tab-structure-block': () => TabStructureBlock,
            'section.feature-pricing': () => FeaturePlanCards,
        };

        window.blocks = new Map();
        for (const [selector, getClass] of Object.entries(selectorClassMap)) {
            const elements = pageContainer.querySelectorAll(selector);
            if (!elements.length) continue;

            let Class;
            try {
                Class = getClass();
            }
            catch (e) {
                console.error(`Error while referencing block class for selector "${selector}":`, e);
                continue;
            }

            const blocks = [];
            const startTime = performance.now();
            for (const element of elements) {
                try {
                    blocks.push(new Class(element));
                }
                catch (e) {
                    console.error(`Error while instantiating block class ${Class.name}:`, e);
                }
            }
            const time = performance.now() - startTime;

            window.blocks.set(Class.name, blocks);

            if (time > 5) {
                console.warn(`Instantiating ${Class.name} ${elements.length > 1 ? 'blocks' : 'block'} took ${time} ms.`);
            }
        }
    }

    console.log('Page ready.');
});
ˇcÊ∞       hThTHPõèh{ô   á    O^userContextId=1&partitionKey=%28https%2Cmega.io%29,:https://mega.io/wp-content/themes/megapages/assets/js/megapages.js?ver=1746139673 strongly-framed 1 security-info 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 request-method GET response-head HTTP/2 200 
server: nginx
date: Thu, 19 Jun 2025 13:09:45 GMT
content-type: application/javascript
content-length: 20522
last-modified: Thu, 01 May 2025 22:47:53 GMT
etag: "6813fa19-502a"
expires: Mon, 30 Jun 2025 23:13:59 GMT
cache-control: max-age=2592000, max-age=2592000
x-cache-status: HIT
accept-ranges: bytes
X-Firefox-Spdy: h2
 original-response-headers server: nginx
date: Thu, 19 Jun 2025 13:09:45 GMT
content-type: application/javascript
content-length: 20522
last-modified: Thu, 01 May 2025 22:47:53 GMT
etag: "6813fa19-502a"
expires: Mon, 30 Jun 2025 23:13:59 GMT
cache-control: max-age=2592000
cache-control: max-age=2592000
x-cache-status: HIT
accept-ranges: bytes
X-Firefox-Spdy: h2
 ctid 2 uncompressed-len 0 net-response-time-onstart 690 net-response-time-onstop 859   P*