/**
 * Scripting for common MEGA WP components.
 */

/**
 * Simple class to handle overlay state.
 */
class Overlay {
    _$overlay;
    _sources = {};

    constructor($overlay) {
        this._$overlay = $overlay;
    }

    enable(sourceKey) {
        if (sourceKey) {
            this._sources[sourceKey] = 1;
        }

        this._$overlay.addClass('active');
        // Assume anything that invokes an overlay will also want to prevent background scrolling.
        $('body').addClass('no-scroll');
    }

    disable(sourceKey) {
        if (sourceKey) {
            delete this._sources[sourceKey];
            if (Object.keys(this._sources).length) return;
        }

        this._$overlay.removeClass('active');

        // Only remove no-scroll if no other overlays are currently active
        if (!($('.overlay').hasClass('active'))) {
            $('body').removeClass('no-scroll');
        }
    }
}

class Header {
    /** @param {HTMLElement} element */
    constructor(element) {
        if (element instanceof jQuery) {
            element = element[0];
        } // TODO remove once projects updated

        this.element = element;

        this.onDocumentClick = this.onDocumentClick.bind(this);

        this.initMenuItems();
        this.initLanguageBtn();
        this.initThemeBtn();
        this.initSearchBtn();
        this.initMobileNavMenuBtn();
    }

    openSubmenu(className) {
        const submenu = this.getSubmenuByClass(className);
        const relatedMenuBtn = this.menuItems.find((item) => item.dataset.target === className);

        this.closeSubmenus();

        if (submenu) {
            // Set submenu outer background colours
            const outerBackgrounds = submenu.dataset.bgs;
            const leftBg = outerBackgrounds['left'] ? '--color-bg-page' : '--color-bg-surface-1';
            const rightBg = outerBackgrounds['right'] ? '--color-bg-page' : '--color-bg-surface-1';
            this.lower.style.background = `linear-gradient(90deg, var(${leftBg}) 50%, var(${rightBg}) 50%)`;
            submenu.classList.remove('hidden');
        }

        if (relatedMenuBtn) {
            relatedMenuBtn.classList.add('active');
        }

        document.addEventListener('click', this.onDocumentClick);
        window.overlayWithHeader.enable('header');
    }

    closeSubmenus() {
        document.removeEventListener('click', this.onDocumentClick);

        for (const item of this.menuItems) {
            item.classList.remove('active');
        }

        for (const submenu of this.submenus) {
            submenu.classList.add('hidden');
        }

        window.overlayWithHeader.disable('header');
    }

    toggleSubmenu(className) {
        const submenu = this.getSubmenuByClass(className);
        if (submenu.classList.contains('hidden')) {
            this.openSubmenu(className);
        }
        else {
            this.closeSubmenus();
        }
    }

    getSubmenuByClass(className) {
        return this.element.querySelector(`.submenu.${className}`);
    }

    onDocumentClick(e) {
        if (this.lower.contains(e.target)) return; // Clicks within a submenu should not close it
        if (this.menuItems.includes(e.target)) return; // Defer clicks on submenu buttons to their listeners

        this.closeSubmenus();
    }

    initMenuItems() {
        this.menuItems = Array.from(this.element.querySelectorAll('button.menu-item'));
        this.lower = this.element.querySelector('.lower');
        this.submenus = this.element.querySelectorAll('.submenu');

        for (const item of this.menuItems) {
            item.addEventListener('click', (e) => {
                const submenuTarget = item.dataset.target;
                if (submenuTarget) {
                    this.toggleSubmenu(submenuTarget);
                    e.stopPropagation();
                }
            });
        }
    }

    initLanguageBtn() {
        this.languageButton = this.element.querySelector('.language-btn');

        if (!this.languageButton) return;

        this.languageButton.addEventListener('click', (e) => {
            ModalRegister.getModal('language-switcher').open();
            e.stopPropagation();
        });
    }

    initThemeBtn() {
        this.themeButton = this.element.querySelector('.theme-btn');

        if (!this.themeButton) return;

        this.themeButtonIcon = this.themeButton.querySelector('.icon');

        this.setThemeBtnIcon();
        ThemeManager.themeChangedEvent.addListener(() => this.setThemeBtnIcon());

        this.themeButton.addEventListener('click', () => {
            ThemeManager.setTheme(ThemeManager.getTheme() === 'dark' ? 'light' : 'dark');
            ThemeManager.savePreference();
        });
    }

    initSearchBtn() {
        this.searchButton = this.element.querySelector('.search-btn');

        if (!this.searchButton) return;

        this.searchButtonIcon = this.searchButton.querySelector('.icon');

        window.mobileSearch.visibilityChangedEvent.addListener((isOpen) => {
            this.mobileMenuButton.classList.toggle('hidden', isOpen);
            this.searchButtonIcon.classList.toggle('search-sro', !isOpen);
            this.searchButtonIcon.classList.toggle('x-mro', isOpen);
        });

        this.searchButton.addEventListener('click', () => {
            window.mobileSearch.toggle();
        });
    }

    initMobileNavMenuBtn() {
        this.mobileMenuButton = this.element.querySelector('.mobile-menu-btn');
        this.mobileMenuButtonIcon = this.mobileMenuButton.querySelector('.icon');

        window.mobileNavMenu.visibilityChangedEvent.addListener((isOpen) => {
            this.mobileMenuButtonIcon.classList.toggle('menu-mro', !isOpen);
            this.mobileMenuButtonIcon.classList.toggle('x-mro', isOpen);
            this.mobileMenuButton.setAttribute('aria-label', isOpen ? 'Close' : 'Menu'); // TODO these should be translated
        });

        this.mobileMenuButton.addEventListener('click', () => {
            window.mobileNavMenu.toggle();
            this.element.classList.toggle('mobile-menu-open', window.mobileNavMenu.isOpen());
        });
    }

    setThemeBtnIcon() {
        this.themeButtonIcon.classList.remove('sun-mro', 'moon-mro');
        this.themeButtonIcon.classList.add(ThemeManager.getTheme() === 'dark' ? 'sun-mro' : 'moon-mro');
    }

    setAccountBtnsVisibility(isVisible) {
        this.element.querySelector('.sign-in-btn').classList.toggle('hidden', !isVisible);
        this.element.querySelector('.sign-up-btn').classList.toggle('hidden', !isVisible);
    }

    /**
     * Set avatar to the default avatar with the given first name and colour.
     *
     * @param {string} firstName
     * @param {string} colour
     */
    setAvatar(firstName, colour) {
        this.element.querySelector('.right-group .vr').classList.remove('hidden');
        const avatarBox = this.element.querySelector('.right-group .avatar-box');
        avatarBox.classList.remove('hidden');
        const avatar = avatarBox.querySelector('.avatar');
        avatar.classList.add(colour);
        avatar.textContent = firstName.charAt(0);
    }

    /**
     * Set avatar to the given URL of a custom avatar.
     *
     * @param {string} url
     */
    setCustomAvatar(url) {
        this.element.querySelector('.right-group .vr').classList.remove('hidden');
        const avatarBox = this.element.querySelector('.right-group .custom-avatar-box');
        avatarBox.classList.remove('hidden');
        avatarBox.querySelector('img').src = url;
    }
}

class Footer {
    constructor(element) {
        if (element instanceof jQuery) element = element[0]; // TODO remove once projects updated
        this.element = element;

        this.accordion = new AccordionComponent(this.element.querySelector('.mobile-links'));
    }
}

/**
 * Base class for modals.
 */
class Modal {
    $modal;
    /** Reference by which to obtain this modal through the {@link ModalRegister}. */
    name;
    /** Optional URL fragment to associate this modal with. */
    fragment;
    overlay = window.overlay;
    onOpened = new Event();
    onClosed = new Event();
    visibilityChangedEvent = new Event();

    constructor(modal) {
        this.modal = modal;
        this.$modal = $(modal);
        this.constrainer = this.modal.parentNode.classList.contains('modal-constrainer') ? this.modal.parentNode : null;

        this.onDocumentClick = this.onDocumentClick.bind(this);
        this.onEscapeKey = this.onEscapeKey.bind(this);
        this.close = this.close.bind(this);

        this.closeButton = modal.querySelector('button.close'); // top-right X
        if (this.closeButton) {
            this.closeButton.addEventListener('click', this.close);
        }
    }

    getName() {
        return this.name;
    }

    isOpen() {
        return !this.modal.classList.contains('hidden');
    }

    open() {
        this.overlay.enable(`modal-${this.name}`);
        if (this.constrainer) this.constrainer.classList.remove('hidden');
        this.modal.classList.remove('hidden');

        document.addEventListener('click', this.onDocumentClick);
        document.addEventListener('keydown', this.onEscapeKey);

        if (this.fragmentMonitor) {
            this.fragmentMonitor.addFragment();
        }

        this.onOpened.invoke();
        this.visibilityChangedEvent.invoke(true);
        console.log(`Modal '${this.name}' opened.`);
    }

    close() {
        document.removeEventListener('keydown', this.onEscapeKey);
        document.removeEventListener('click', this.onDocumentClick);

        this.modal.classList.add('hidden');
        if (this.constrainer) this.constrainer.classList.add('hidden');
        this.overlay.disable(`modal-${this.name}`);

        if (this.fragmentMonitor) {
            this.fragmentMonitor.removeFragment();
        }

        this.onClosed.invoke();
        this.visibilityChangedEvent.invoke(false);
        console.log(`Modal '${this.name}' closed.`);
    }

    setOpen(state) {
        if (state) {
            this.open();
        }
        else {
            this.close()
        }
    }

    toggle() {
        this.setOpen(!this.isOpen());
    }

    setTitle(title) {
        this.heading ||= this.modal.querySelector('.heading');

        this.heading.textContent = title;
    }

    setBlurb(blurb) {
        this.blurb ||= this.modal.querySelector('.blurb');

        this.blurb.textContent = blurb;
    }

    setImage(url) {
        this.imgBox ||= this.modal.querySelector('.img-box');
        this.img ||= this.imgBox.querySelector('.img');
        this.img.style.backgroundImage = `url('${url}')`;
        this.imgBox.classList.toggle('hidden', !url);
    }

    onDocumentClick(e) {
        if (this.modal.contains(e.target)) return;

        this.close();
    }

    onEscapeKey(e) {
        if (e.key !== "Escape") {
            return;
        }
        this.close();
    }

    _monitorFragment(fragment) {
        this.fragmentMonitor = new FragmentMonitor(fragment);
        if (this.fragmentMonitor.isMatch) {
            this.open();
        }

        this.fragmentMonitor.onFragmentChanged.addListener((isMatch) => {
            if (isMatch && !this.isOpen()) {
                this.open();
            }
            else if (!isMatch && this.isOpen()) {
                this.close();
            }
        });
    }
}

/** Instantiate new, generic message modals. */
class MessageModal {
    /**
     * Create and display a new message modal with the given title and blurb.
     * The modal will have an "OK" primary button by default, which simply dismisses the modal.
     *
     * @param {string} name Name (handle) of the modal.
     * @param {string} title Title of the modal.
     * @param {string} blurb Blurb or description for the modal.
     */
    constructor(name, title = '', blurb = '') {
        const modals = document.querySelector('.modals');
        const template = modals.querySelector('template.generic-msg-modal');
        const templateInstance = template.content.firstElementChild.cloneNode(true);
        modals.appendChild(templateInstance);
        const modalElement = templateInstance.querySelector('dialog.modal');

        this.modal = new Modal(modalElement);
        this.modal.name = name;
        this.modal.setTitle(title);
        this.modal.setBlurb(blurb);

        this._buttonCache = { };

        // Default behaviour
        this.setPrimaryButton(template.dataset.defaultPrimaryBtnLabel, '', () => this.hide());
        this.show();
    }

    show() {
        this.modal.open();
    }

    hide() {
        this.modal.close();
    }

    /**
     * Set the modal's details as from ModalComponent block component attributes.
     *
     * @param {object} modalDetails
     */
    setDetails(modalDetails) {
        this.modal.setTitle(modalDetails.title);
        this.modal.setBlurb(modalDetails.blurb);
        this.modal.setImage(modalDetails.image.url);

        const primary = modalDetails.buttonPrimary;
        const secondary = modalDetails.buttonSecondary;

        this.setPrimaryButton(primary.label, primary.href, primary.action);
        this.setSecondaryButton(secondary.label, secondary.href, secondary.action);
    }

    /**
     * Set up a primary button for the modal.
     *
     * @param {string} label
     * @param {string} href
     * @param {function()} action
     */
    setPrimaryButton(label, href = '', action = null) {
        this._setButton('primaryButton', label, href, action);
    }

    /** Set up a secondary button for the modal.
     *
     * @param {string} label
     * @param {string} href
     * @param {function()} action
     */
    setSecondaryButton(label, href = '', action = null) {
        this._setButton('secondaryButton', label, href, action);
    }

    _setButton(buttonClass, label, href = '', action = null) {
        const cache = this._buttonCache[buttonClass] ||= { };
        cache['link'] ||= this.modal.modal.querySelector(`a.${buttonClass}`);
        cache['button'] ||= this.modal.modal.querySelector(`button.${buttonClass}`);
        cache['link'].classList.add('hidden');
        cache['button'].classList.add('hidden');

        let button = cache['button'];
        if (href) {
            button = cache['link'];
            button.href = href;
        }

        button.textContent = label;
        if (cache['action']) {
            cache['link'].removeEventListener('click', cache['action']);
            cache['button'].removeEventListener('click', cache['action']);
        }
        if (action && typeof action === 'function') {
            cache['action'] = action;
            button.addEventListener('click', cache['action']);
        }

        if (label && (href || action)) {
            button.classList.remove('hidden');
        }
    }
}

class MobileMenuModal extends Modal {
    name = 'mobile-menu';

    constructor(modal) {
        super(modal);
        this.overlay = window.overlayWithHeader;

        this.toggleThemeBtn = this.modal.querySelector('.theme-btn');
        this.languageBtn = this.modal.querySelector('.language-btn');
        this.bottomBar = this.modal.querySelector('.bottom-bar');

        const accordionContainer = this.modal.querySelector('.accordions, .scroll-pane');
        if (accordionContainer) {
            this.accordion = new AccordionComponent(accordionContainer);
        }

        this.onBreakpointChanged = this.onBreakpointChanged.bind(this);

        this.toggleThemeBtn.addEventListener('click', () => {
            ThemeManager.setTheme(ThemeManager.getTheme() === 'dark' ? 'light' : 'dark');
            ThemeManager.savePreference();
        });

        if (this.languageBtn) {
            this.languageBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                ModalRegister.getModal('language-switcher').open();
            });
        }

        ThemeManager.themeChangedEvent.addListener(() => this.updateThemeBtn());

        this.updateThemeBtn();
    }

    open() {
        super.open();
        Breakpointer.breakpointChangedEvent.addListener(this.onBreakpointChanged);
    }

    close() {
        super.close();
        Breakpointer.breakpointChangedEvent.removeListener(this.onBreakpointChanged);
    }

    setAccountBtnsVisibility(isVisible) {
        this.bottomBar.classList.toggle('hidden', !isVisible);
    }

    updateThemeBtn() {
        const buttonText = this.toggleThemeBtn.querySelector('.label');
        const buttonIcon = this.toggleThemeBtn.querySelector('.icon');

        if (ThemeManager.getTheme() === 'dark') {
            buttonText.textContent = this.toggleThemeBtn.dataset.lightText;
            buttonIcon.classList.remove('moon-mro');
            buttonIcon.classList.add('sun-mro');
        }
        else {
            buttonText.textContent = this.toggleThemeBtn.dataset.darkText;
            buttonIcon.classList.remove('sun-mro');
            buttonIcon.classList.add('moon-mro');
        }
    }

    onBreakpointChanged(newBreakpoint) {
        if (newBreakpoint.gt(Breakpoint.MD)) {
            this.close();
        }
    }

    onDocumentClick(e) {
        // Do nothing; override default behaviour
    }
}

class MobileSearchModal extends Modal {
    name = 'mobile-search';
    $searchInput;

    constructor($modal) {
        super($modal[0]);
        this.overlay = window.overlayWithHeader;
        this.$searchInput = $('.search-field', this.$modal);

        this.onBreakpointChanged = this.onBreakpointChanged.bind(this);
    }

    open() {
        super.open();
        this.$searchInput.trigger('focus');
        Breakpointer.breakpointChangedEvent.addListener(this.onBreakpointChanged);
    }

    close() {
        super.close();
        Breakpointer.breakpointChangedEvent.removeListener(this.onBreakpointChanged);
    }

    onBreakpointChanged(newBreakpoint) {
        if (newBreakpoint.gt(Breakpoint.MD)) {
            this.close();
        }
    }

    onDocumentClick(e) {
        // Do nothing; override default behaviour
    }
}

class LanguageSwitcher extends Modal {
    name = 'language-switcher';

    constructor(modal) {
        super(modal);

        this.options = this.modal.querySelectorAll('.language-option');
        this.saveButton = this.modal.querySelector('button.save-language');

        for (const option of this.options) {
            option.addEventListener('click', () => {
                this._getActiveOption().classList.remove('active');
                option.classList.add('active');
            });
        }

        this.saveButton.addEventListener('click', () => {
            const url = this._getActiveOption().dataset.link;
            if (url) {
                Prefs.set('language', this._getActiveOption().dataset.code);
                window.location.href = url;
            }

            this.close();
        });

        this._monitorFragment('#choose-language');
    }

    _getActiveOption() {
        return this.modal.querySelector('.language-option.active');
    }
}

/**
 * Base class for expandable components.
 */
class ExpandableComponent {
    constructor(element) {
        if (element instanceof jQuery) element = element[0]; // TODO remove once projects updated
        this.element = element;
    }

    isExpanded() {
        return this.element.classList.contains('expanded');
    }

    expand() {
        this.element.classList.add('expanded');
    }

    contract() {
        this.element.classList.remove('expanded');
    }

    toggle() {
        if (this.isExpanded()) {
            this.contract();
        }
        else {
            this.expand();
        }
    }
}

class ShowHideComponent extends ExpandableComponent {
    constructor(element) {
        if (element instanceof jQuery) element = element[0]; // TODO remove once projects updated
        super(element);

        this.element.querySelector('.show-hide-toggle').addEventListener('click', () => this.toggle());
    }
}

class AccordionLeaf extends ExpandableComponent {
    expandStartEvent = new Event();

    constructor(element) {
        if (element instanceof jQuery) element = element[0]; // TODO remove once projects updated
        super(element);

        this.onToggled = new Event();

        this.element.querySelector('.accordion-toggle').addEventListener('click', () => {
            this.onToggled.invoke();
            this.toggle();
        });
    }

    expand() {
        this.expandStartEvent.invoke();
        super.expand();
    }

    setTransitionDuration(ms) {
        this.element.style.setProperty(['--transition-time'], `${ms}ms`);
    }
}

class AccordionComponent {
    constructor(element) {
        if (element instanceof jQuery) element = element[0]; // TODO remove once projects updated
        this.element = element;
        this.leaves = [];

        for (const leafElement of this.element.querySelectorAll('.accordion')) {
            this.leaves.push(new AccordionLeaf(leafElement));
        }

        this.setMultiLeaf(false);
    }

    /**
     * Set whether any open leaves should be closed when a new leaf is expanded.
     *
     * @param isMultiLeaf if true, open leaves will not be automatically closed when a new leaf is expanded.
     */
    setMultiLeaf(isMultiLeaf) {
        if (isMultiLeaf) {
            for (const leaf of this.leaves) {
                leaf.onToggled.removeListener(leaf._accListener);
            }
        }
        else {
            for (const leaf of this.leaves) {
                leaf._accListener = leaf._accListener || (() => this._onToggle(leaf));
                leaf.onToggled.addListener(leaf._accListener);
            }
        }
    }

    setTransitionDuration(ms) {
        for (const leaf of this.leaves) {
            leaf.setTransitionDuration(ms);
        }
    }

    _onToggle(toggledLeaf) {
        for (const leaf of this.leaves) {
            if (leaf !== toggledLeaf && leaf.isExpanded()) {
                leaf.contract();
            }
        }
    }
}

/** Scripting for the search component. */
class SearchComponent {
    searchSuggestions = [];

    /**
     * @param {HTMLElement} element HTML element for the search component main div.
     */
    constructor(element) {
        this.element = element;
        this.searchField = this.element.querySelector('.search-field');
        this.clearButton = this.element.querySelector('.input-clear-txt');
        this.suggestionsList = this.element.querySelector('.search-suggestions');
        for (const suggestion of this.suggestionsList.children) {
            this.searchSuggestions.push({
                label: suggestion.textContent,
                tags: JSON.parse(suggestion.dataset.tags).map(tag => tag.toLowerCase()),
                url: suggestion.href,
            });
        }

        this.suggestionsList.replaceChildren();

        this.clearInputAndFocus = this.clearInputAndFocus.bind(this);
        this.onDocumentClick = this.onDocumentClick.bind(this);

        this.searchField.addEventListener('input', () => this.setClearBtnState());

        this.setClearBtnState();
        this.initSearchSuggestions();
    }

    get value() {
        return this.searchField.value;
    }

    openSuggestionList() {
        this.suggestionsList.classList.remove('hidden');
        document.addEventListener('click', this.onDocumentClick);
    }

    closeSuggestionList() {
        this.suggestionsList.classList.add('hidden');
        document.removeEventListener('click', this.onDocumentClick);
    }

    onDocumentClick(e) {
        if (e.target && this.element.contains(e.target)) return;
        this.closeSuggestionList();
    }

    setClearBtnState() {
        if (this.value) {
            this.clearButton.removeEventListener('click', this.clearInputAndFocus); // Bind the listener just once
            this.clearButton.addEventListener('click', this.clearInputAndFocus);
            this.clearButton.classList.remove('hidden');
        }
        else {
            this.clearButton.removeEventListener('click', this.clearInputAndFocus);
            this.clearButton.classList.add('hidden');
        }
    }

    clearInputAndFocus() {
        this.searchField.value = '';
        this.setClearBtnState();
        this.searchField.focus();
    }

    initSearchSuggestions() {
        this.searchField.addEventListener('focus', () => {
            const query = this.value.replace("'", "’");

            if (this.tryPopulateSuggestions(query)) {
                this.openSuggestionList();
            }
        });

        this.searchField.addEventListener('input', () => {
            const query = this.value.replace("'", "’");

            if (this.tryPopulateSuggestions(query)) {
                this.openSuggestionList();
            }
            else {
                this.closeSuggestionList();
            }
        });
    }

    tryPopulateSuggestions(query) {
        this.suggestionsList.replaceChildren();

        // Don't filter with empty string.
        if (!query) return false;

        const keywords = query.trim().split(/\s+/).map(word => word.toLowerCase());
        const regex = new RegExp(keywords.map(word => `\\b${RegExp.escape(word)}`).join('|'), 'i');

        const suggestions = this.searchSuggestions.filter(suggestion => regex.test(suggestion.label)
                || (suggestion.tags && suggestion.tags.some(tag => keywords.includes(tag.toLowerCase()))));

        if (!suggestions.length) return false;

        const fragment = document.createDocumentFragment();
        for (const suggestion of suggestions.slice(0, 5)) {
            fragment.appendChild(this.generateSearchSuggestion(suggestion.label, suggestion.url, keywords));
        }
        this.suggestionsList.appendChild(fragment);

        return true;
    }

    generateSearchSuggestion(label, url, keywords) {
        const highlightedFragment = this.highlightKeywords(label, keywords);

        const suggestion = document.createElement('a');
        suggestion.href = url;
        suggestion.appendChild(highlightedFragment);

        return suggestion;
    }

    highlightKeywords(text, keywords) {
        const pattern = new RegExp(`(${keywords.map(word => `\\b${RegExp.escape(word)}`).join('|')})`, 'gi');

        const parts = text.split(pattern);
        const fragment = document.createDocumentFragment();

        for (const part of parts) {
            if (pattern.test(part)) {
                const boldElement = document.createElement('b');
                boldElement.textContent = part;
                fragment.appendChild(boldElement);
            }
            else {
                fragment.appendChild(document.createTextNode(part));
            }
        }

        return fragment;
    }
}

class SearchForm {
    constructor(element) {
        this.element = element;
        this.searchComponent = new SearchComponent(this.element.querySelector('.search-component'));

        this.element.addEventListener('submit', (e) => {
            if (!this.searchComponent.value.trim()) {
                // prevent submission if empty
                e.preventDefault();
            }
        });
    }
}

/**
 * Scripting for the dropdown component.
 */
class DropdownComponent {
    onOpenedEvent = new Event();
    onClosedEvent = new Event();
    selectionChangedEvent = new Event();

    _search = '';
    _searchCooldown;

    /**
     * @param {HTMLDivElement} element HTMLDivElement for the dropdown component main div.
     */
    constructor(element) {
        this.element = element;
        this.selector = this.element.querySelector('.selector');
        this.selectorText = this.selector.querySelector('.selector-text');
        this.selectorIcon = this.selector.querySelector('.selector-icon');
        this.optionsList = this.element.querySelector('.options-list');

        this.options = Array.from(this.optionsList.querySelectorAll('.option'));
        this.selectedOptions = Array.from(this.optionsList.querySelectorAll('.selected'));
        if (this.selectedOptions.length) {
            this._selectOption(this.selectedOptions[0]);
        }

        this.selector.addEventListener('click', () => this._onSelectorActivate());
        this.selector.addEventListener('keyup', (event) => {
            if (event.key !== 'Enter') return;

            this._onSelectorActivate();
        });

        for (const option of this.options) {
            option.addEventListener('click', (e) => this._onOptionClick(e));
            option.addEventListener('blur', (e) => this._onOptionBlur(e));
            option.addEventListener('keydown', (e) => this._onOptionKeyDown(e));
        }

        const form = this.element.closest('form');
        if (form) {
            form.addEventListener('reset', () => this.reset());
        }
    }

    get isOpen() { return this.element.classList.contains('active') };

    get value() { return this.getSelected().value; }

    set value(value) { this.selectOption(value); }

    selectOption(value, suppressEvents) {
        const option = this.optionsList.querySelector(`.option[data-value="${value}"]`);
        if (!option) {
            console.warn(`Attempted to select a non-existing select option with value ${value}. Ignoring.`);
            return;
        }

        this._selectOption(option, suppressEvents);
    }

    _selectOption(option, noEvents) {
        for (const opt of this.selectedOptions) {
            opt.classList.remove('selected');
        }

        if (option) {
            option.classList.add('selected');
        }

        this.selectedOptions = option ? [option] : [];

        this._determineSelectorText();

        if (option && this.isOpen) {
            option.focus();
        }

        if (!noEvents) {
            // Emulate native 'change' event
            this.element.dispatchEvent(new CustomEvent('change', { bubbles: true }));
            this.selectionChangedEvent.invoke(this.getSelected());
        }
    }

    getSelected() {
        const option = this.selectedOptions[0];

        return {
            name: option ? option.textContent : undefined,
            value: option ? option.dataset.value : undefined,
        }
    }

    open() {
        this.element.classList.add('active');
        this.optionsList.classList.remove('hidden');
        this.selectorIcon.classList.add('chevron-up-mro');
        this.selectorIcon.classList.remove('chevron-down-mro');
        const firstOption = this.selectedOptions[0] || this.options[0];
        if (firstOption) {
            firstOption.focus();
        }

        this.onOpenedEvent.invoke();
    }

    close() {
        this.element.classList.remove('active');
        this.optionsList.classList.add('hidden');
        this.selectorIcon.classList.add('chevron-down-mro');
        this.selectorIcon.classList.remove('chevron-up-mro');
        this.onClosedEvent.invoke();
    }

    reset() {
        this.close();

        // True for no event invocation on 'reset' event to match native input element behaviour
        this._selectOption(undefined, true);
    }

    /**
     * Set the size of this particular dropdown component.
     *
     * @param sizeClass Name of the size class. Expecting 'lg', 'md', 'sm'.
     */
    setSize(sizeClass) {
        const sizes = ['lg', 'md', 'sm'];

        if (sizes.includes(sizeClass)) {
            this.element.classList.remove(...sizes);
            this.element.classList.add(sizeClass);
        }
    }

    addOption(value, name) {
        this.optionTemplate = this.optionTemplate || this.optionsList.querySelector('template');
        const newOption = this.optionTemplate.content.cloneNode(true).firstChild;

        newOption.querySelector('.name').textContent = name;
        newOption.dataset.value = value;
        newOption.addEventListener('click', (e) => this._onOptionClick(e));
        newOption.addEventListener('blur', (e) => this._onOptionBlur(e));
        newOption.addEventListener('keydown', (e) => this._onOptionKeyDown(e));

        this.optionsList.appendChild(newOption);
        this.options.push(newOption);
    }

    showErrorHighlight() {
        this.selector.classList.add('error-highlight');
    }

    hideErrorHighlight() {
        this.selector.classList.remove('error-highlight');
    }

    _determineSelectorText() {
        this.selectorText.textContent = this.selectedOptions.length > 0
            ? this.selectedOptions[0].textContent
            : this.selectorText.dataset.placeholder;
    }

    _onSelectorActivate() {
        if (this.optionsList.classList.contains('hidden')) {
            this.open();
        }
        else {
            this.close();
        }
    }

    _onOptionClick(event) {
        this._selectOption(event.currentTarget);
        this.close();
    }

    _onOptionBlur(event) {
        if (!this.isOpen) return; // Dropdown already closed, ignore
        if (this.element.contains(event.relatedTarget)) return; // If focus went to dropdown component root element or within, ignore / defer

        this.close();
    }

    _onOptionKeyDown(event) {
        if (event.key === 'Escape') {
            this.close();
        }
        else if (event.key === 'Enter') {
            this._selectOption(event.currentTarget);
            this.close();
        }
        else if (event.key === 'ArrowUp') {
            if (event.currentTarget.previousElementSibling) {
                event.currentTarget.previousElementSibling.focus();
            }
            event.preventDefault(); // Don't scroll
        }
        else if (event.key === 'ArrowDown') {
            if (event.currentTarget.nextElementSibling) {
                event.currentTarget.nextElementSibling.focus();
            }
            event.preventDefault();
        }
        else {
            // Try to focus option by search
            this._search += event.key;

            const option = this.options.find((option) => {
                return option.textContent.trim().toLowerCase().startsWith(this._search);
            });
            if (option) {
                option.focus();
            }

            clearTimeout(this._searchCooldown);
            this._searchCooldown = setTimeout(() => {
                this._search = '';
            }, 750);
        }
    }
}

class MultiselectDropdown extends DropdownComponent {
    constructor($dropdownElement) {
        super($dropdownElement);

        // Finding selected options by checkbox value and not .selected class
        // allows value to be remembered after refreshing page
        this.selectedOptions = Array.from(this.optionsList.querySelector(':has(input[type="checkbox"]:checked)'));
        for (const element of this.selectedOptions) {
            this._selectOption(element);
        }
    }

    getSelected() {
        return this.selectedOptions.map((element) => ({
            name: element.querySelector('.name').textContent,
            value: element.dataset.value,
        }));
    }

    clearSelected(noEvent) {
        for (const option of this.selectedOptions) {
            option.checked = false;
            option.classList.remove('selected');
        }

        this.selectedOptions = [];

        if (!noEvent) {
            this._determineSelectorText();
            this.selectionChangedEvent.invoke({ });
        }
    }

    addOption(value, name) {
        // TODO stub
    }

    reset() {
        this.close();
        // True for no event invocation on 'reset' event to match native input element behaviour
        this.clearSelected(true);
    }

    _selectOption(option) {
        option.classList.toggle('selected');
        option.querySelector('.checkbox').checked = option.classList.contains('selected');

        this.selectedOptions = Array.from(this.optionsList.querySelectorAll('.selected'));
        this._determineSelectorText();
        option.focus();
        this.selectionChangedEvent.invoke(this.getSelected());
    }

    _determineSelectorText() {
        if (this.selectedOptions.length < 1) {
            this.selectorText.textContent = this.element.dataset.placeholder;
        }
        else if (this.selectedOptions.length < 2) {
            this.selectorText.textContent = this.selectedOptions[0].textContent;
        }
        else {
            this.selectorText.textContent = this.element.dataset.pluralSelector.replace('%1', this.selectedOptions.length.toString());
        }
    }

    _onOptionClick(event) {
        this._selectOption(event.currentTarget);
    }

    _onOptionKeyDown(event) {
        if (event.key === 'Enter') {
            this._selectOption(event.currentTarget);
        }
        else {
            super._onOptionKeyDown(event);
        }
    }
}

class ToggleControl {
    constructor(toggle) {
        this.toggle = toggle;

        this.toggle.addEventListener('click', () => {
            if (this.toggle.classList.contains('disabled')) return;

            this.value = !this.value;
        });

        this.toggle.addEventListener('keydown', (e) => {
            if (e.key !== ' ' && e.key !== 'Enter') return;

            if (this.toggle.classList.contains('disabled')) return;

            this.value = !this.value;
        });
    }

    get value() {
        return this.toggle.classList.contains('on');
    }

    set value(value) {
        this.toggle.classList.toggle('on', value);
        this.toggle.classList.toggle('off', !value);
    }
}

class RadioOptions {
    /** @type HTMLDivElement */
    radioOptions;

    constructor(element) {
        this.radioOptions = element;

        this._setCustomInputVisibility(this._selectedOption);

        for (const element of this.radioOptions.querySelectorAll('.input-n-label input')) {
            element.addEventListener('change', (event) => {
                const option = event.target.parentElement.parentElement;
                this._setCustomInputVisibility(option);
            });
        }
    }

    get value() {
        const option = this._selectedOption;
        if (!option) return null;

        return option.classList.contains('custom-option')
            ? option.querySelector('input.custom-input').value
            : option.querySelector('.input-n-label input').value;
    }

    set value(value) {
        const input = this.radioOptions.querySelector(`.input-n-label input[value="${value}"]`);
        if (!input) {
            console.warn(`Attempted to select a non-existing radio option with value ${value}. Ignoring.`);
            return;
        }

        input.checked = true;
    }

    get isCustomSelected() {
        const option = this._selectedOption;
        if (!option) return false;

        return option.classList.contains('custom-option');
    }

    get _selectedOption() {
        const input = this.radioOptions.querySelector('.input-n-label input:checked');
        if (!input) return null;

        return input.parentElement.parentElement;
    }

    showErrorHighlight() {
        if (this.isCustomSelected) {
            this.radioOptions.querySelector('input.custom-input').classList.add('error-highlight');
        }
    }

    hideErrorHighlight() {
        const customInput = this.radioOptions.querySelector('input.custom-input');
        if (!customInput) return;

        customInput.classList.remove('error-highlight');
    }

    _setCustomInputVisibility(option) {
        // Hide other custom inputs
        for (const element of this.radioOptions.querySelectorAll('input.custom-input')) {
            element.classList.add('hidden');
        }

        if (option && option.classList.contains('custom-option')) {
            const customInput = option.querySelector('input.custom-input');
            customInput.classList.remove('hidden');
        }
    }
}

class CarouselComponent {
    $carousel;
    $controlButtons;
    $content;
    content;

    constructor(element) {
        this.element = element instanceof jQuery ? element[0] : element; // TODO remove once projects updated
        this.$carousel = $(element);
        this.$controlButtons = $('.carousel-controls button', this.$carousel);
        this.$content = $('.carousel-content', this.$carousel);
        this.content = this.$content[0];

        if (!this.content || !this.$controlButtons.length) {
            console.error(`Missing elements in '${this.$carousel.attr('class')}' carousel.`);
            return;
        }

        this.$controlButtons.on('click', (e) => {
            // Assume the content has a 'gap' property (but this is really up to the implementer - fix if needed)
            const gridGap = parseInt(this.$content.css('gap'));
            const itemWidth = parseInt(this.$content.children().first().css('width'));

            // Ensure each item gets 100 % visibility at some point during scrolling
            const itemFitCount = Math.floor(this.content.clientWidth / itemWidth);
            const scrollAmount = Math.min(this.content.clientWidth + gridGap, (itemWidth + gridGap) * itemFitCount);

            this.scrollTo($(e.currentTarget).hasClass('left')
                ? this.content.scrollLeft - scrollAmount
                : this.content.scrollLeft + scrollAmount);
        });

        $(this.content).on('scroll', () => this.setButtonStates());

        // Reading .scrollLeft may trigger reflow; wait until the browser is idle
        requestIdleCallback(() => this.setButtonStates());
    }

    get itemCount() { return this.$content.children().length }

    scrollTo(leftValue) {
        this.content.scroll({
            left: leftValue,
            behavior: 'smooth',
        });
    }

    setButtonStates() {
        if (document.documentElement.dir === 'rtl') {
            this.$controlButtons[1].disabled = this.content.scrollLeft >= 0;
            this.$controlButtons[0].disabled = 0 - this.content.scrollLeft + this.content.clientWidth >= this.content.scrollWidth;
        }
        else {
            this.$controlButtons[0].disabled = this.content.scrollLeft <= 0;
            this.$controlButtons[1].disabled = this.content.scrollLeft + this.content.clientWidth >= this.content.scrollWidth;
        }
    }
}

class TabStructure {
    constructor(element) {
        this.tabStructure = element;

        this.onTabChanged = new Event();

        this._tabIds = [];
        this._tablist = this.tabStructure.querySelector('.tab-buttons');
        this._tabButtons = this._tablist.querySelectorAll('.tab-button');
        this._tabPanes = this.tabStructure.querySelectorAll('.tab-pane');

        if (this.tabStructure.dataset.tablistSpan) {
            this.setTablistSpan(this.tabStructure.dataset.tablistSpan);
            Breakpointer.breakpointChangedEvent.addListener(() => this.setTablistSpan(this.tabStructure.dataset.tablistSpan));
        }

        for (const tabButton of this._tabButtons) {
            this._tabIds.push(tabButton.dataset.tabId);
            tabButton.addEventListener('click', () => {
                this.setActiveTab(tabButton.dataset.tabId);

                const logId = parseInt(tabButton.dataset.logId);
                if (logId) {
                    Api.log(logId);
                }
            });
        }

        // Prevent layout shift when emboldening the labels by reserving space for the bold lettering in CSS
        if (this.tabStructure.classList.contains('type-b')) {
            for (const tabButton of this._tabButtons) {
                const title = tabButton.querySelector('.tab-title');
                title.dataset.title = title.textContent;
            }
        }

        if (this._tabPanes.length > 0) {
            this.setActiveTab(this._tabPanes[0].dataset.tabId);
        }
    }

    get tabIds() { return this._tabIds; }

    get tabButtons() { return this._tabButtons; }

    get tabPanes() { return this._tabPanes; }

    setTablistSpan(columns) {
        if (Breakpointer.currentBreakpoint.gt(Breakpoint.MD)) {
            this._tablist.style.gridColumn = `span ${columns}`;
        }
        else {
            this._tablist.style.removeProperty('grid-column');
        }
    }

    getTabPane(tabId) {
        return Array.from(this._tabPanes).find((pane) => pane.dataset.tabId === tabId);
    }

    setActiveTab(tabId) {
        for (const tabButton of this._tabButtons) {
            tabButton.classList.toggle('active', tabButton.dataset.tabId == tabId);
        }

        for (const tabPane of this._tabPanes) {
            tabPane.classList.toggle('hidden', tabPane.dataset.tabId != tabId);
        }

        if (this.tabStructure.classList.contains('type-b')) {
            // Reading .scrollLeft may trigger reflow; wait until the browser is idle
            requestIdleCallback(() => this.scrollToButton(tabId));
        }

        this.onTabChanged.invoke(tabId);
        this.activeTab = tabId;
    }

    /** Side-scroll the button of the given tab ID into view, if needed */
    scrollToButton(tabId) {
        // TODO use Utils.scrollIntoViewX() instead (set scroll margins)
        if (this._tablist.offsetWidth >= this._tablist.scrollWidth) return; // No scrolling required. All buttons are in view.

        const scrollTo = (leftOffset) => {
            this._tablist.scrollTo({
                left: leftOffset,
                behavior: 'smooth',
            });
        };

        const button = Array.from(this._tabButtons).find(button => button.dataset.tabId == tabId);
        if (!button) return;

        const maskLeftEdge = this._tablist.scrollLeft;
        const maskRightEdge = this._tablist.scrollLeft + this._tablist.offsetWidth;
        const buttonLeftEdge = button.offsetLeft;
        const buttonRightEdge = button.offsetLeft + button.offsetWidth;

        // Somewhat arbitrary offset to ensure adjacent buttons are revealed,
        // provided the clicked button doesn't take all the space (therefore 0-54px)
        const offset = Math.min(Math.max(this._tablist.offsetWidth - button.offsetWidth, 0), 54);

        if (buttonLeftEdge <= maskLeftEdge) {
            scrollTo(buttonLeftEdge - offset);
        }
        else if (buttonRightEdge > maskRightEdge) {
            scrollTo(buttonRightEdge + offset - this._tablist.offsetWidth);
        }
    }
}

class ToastNotification {
    constructor(element) {
        this.toast = element;
        this.messageElement = this.toast.querySelector('.message');

        this.toast.querySelector('button.close').addEventListener('click', () => this.hide());
    }

    setMessage(message) {
        this.toast.querySelector('.message').textContent = message;
    }

    showMessage(message, timeout) {
        this.setMessage(message);
        this.show(timeout);
    }

    show(timeout) {
        this.toast.classList.remove('hidden');

        clearTimeout(this._tandle);

        if (timeout <= 0) return;

        this._tandle = setTimeout(() => {
            this.hide();
        }, timeout);
    }

    hide() {
        this.toast.classList.add('hidden');
        clearTimeout(this._tandle);
    }
}

/**
 * Simple controller for the radio button group component.
 */
class RadioGroup {
    $group;
    $buttons;
    selectionChangedEvent = new Event();

    constructor($group) {
        this.$group = $group;
        this.$buttons = $('.radio-option-btn', this.$group);

        this.$buttons.on('click', (e) => {
            this.setActiveButton(e.target);
        });
    }

    getActiveButton() {
        return this.$buttons.filter('.active')[0];
    }

    setActiveButton(button) {
        this.$buttons.removeClass('active');

        if (button && this.$group.has(button).length) {
            button.classList.add('active');
            this.selectionChangedEvent.invoke(button);
        }
        else {
            this.selectionChangedEvent.invoke();
        }
    }
}

class CookieBanner {
    /** @type HTMLDivElement */
    banner;

    /**
     * @param {HTMLDivElement} cookieBanner
     */
    constructor(cookieBanner) {
        this.banner = cookieBanner;

        this.acceptAllCookies = this.acceptAllCookies.bind(this);
        this.rejectNonessentialCookies = this.rejectNonessentialCookies.bind(this);

        this.banner.querySelector('button.accept-all').addEventListener('click', this.acceptAllCookies);

        this.init();
    }

    async init() {
        if (!CookieSettings.isConsentSet()) {
            await this.displayRejectButton();
            this.show();
            CookieSettings.onConsentChanged.addListener(() => this.hide());
        }
    }

    async displayRejectButton() {
        const currency = await L10n.getLocalCurrency();
        const getLocalCountry = await L10n.getCountry();

        // GDPR countries but not use euro
        const GDPR = ['BG', 'HR', 'CZ', 'DK', 'HU', 'PL', 'RO', 'SE', 'UK'];

        if (currency === 'EUR' || GDPR.includes(getLocalCountry)) {
            this.banner.querySelector('button.reject').classList.remove('hidden');
            this.banner.querySelector('button.reject').addEventListener('click', this.rejectNonessentialCookies);
        }
    }

    show() {
        this.banner.classList.remove('hidden');
    }

    hide() {
        this.banner.classList.add('hidden');
    }

    acceptAllCookies() {
        CookieSettings.setConsent({
            preferences: true,
            analytics: true,
            marketing: true,
        });

        console.log('All cookies accepted.');
        this.banner.classList.add('hidden');
    }

    rejectNonessentialCookies() {
        CookieSettings.setConsent({
            preferences: false,
            analytics: false,
            marketing: false,
        });

        console.log('Non-essential cookies rejected.');
        this.banner.classList.add('hidden');
    }
}

class CookieDialog extends Modal {
    name = 'cookie-dialog';

    constructor(modal) {
        super(modal);

        this.preferencesToggle = new ToggleControl(this.modal.querySelector('.toggle-control.preferences'));
        this.analyticsToggle = new ToggleControl(this.modal.querySelector('.toggle-control.analytics'));
        this.marketingToggle = new ToggleControl(this.modal.querySelector('.toggle-control.marketing'));

        this.modal.querySelector('button.save').addEventListener('click', () => this.onSave());

        this._monitorFragment('#cookie-settings');
        this.loadValues();
        CookieSettings.onConsentChanged.addListener(this.loadValues.bind(this));
    }

    loadValues() {
        if (CookieSettings.isConsentSet()) {
            const consent = CookieSettings.getConsent();

            this.preferencesToggle.value = !!consent.preferences;
            this.analyticsToggle.value = !!consent.analytics;
            this.marketingToggle.value = !!consent.marketing;
        }
    }

    onSave() {
        CookieSettings.setConsent({
            preferences: this.preferencesToggle.value,
            analytics: this.analyticsToggle.value,
            marketing: this.marketingToggle.value,
        });

        this.close();
    }
}

class SplitFlapTimer {
    constructor(element) {
        this.element = element;

        this.daysCell0 = this.element.querySelector('.days .cell:first-child');
        this.daysCell1 = this.element.querySelector('.days .cell:nth-child(2)');
        this.hoursCell0 = this.element.querySelector('.hours .cell:first-child');
        this.hoursCell1 = this.element.querySelector('.hours .cell:nth-child(2)');
        this.minutesCell0 = this.element.querySelector('.minutes .cell:first-child');
        this.minutesCell1 = this.element.querySelector('.minutes .cell:nth-child(2)');
    }

    setTime(seconds) {
        this._time = seconds;

        const days = Math.floor(seconds / (3600 * 24));

        seconds -= days * 3600 * 24;
        const hours = Math.floor(seconds / 3600);

        seconds -= hours * 3600
        const minutes = Math.floor(seconds / 60);

        this.setDays(days);
        this.setHours(hours);
        this.setMinutes(minutes);
    }

    setDays(days) {
        days = Math.floor(days);
        days = Math.max(0, Math.min(99, days));
        days = days.toString().padStart(2, '0');

        this.daysCell0.textContent = days.charAt(0);
        this.daysCell1.textContent = days.charAt(1);
    }

    setHours(hours) {
        hours = Math.floor(hours);
        hours = Math.max(0, Math.min(99, hours));
        hours = hours.toString().padStart(2, '0');

        this.hoursCell0.textContent = hours.charAt(0);
        this.hoursCell1.textContent = hours.charAt(1);
    }

    setMinutes(minutes) {
        minutes = Math.floor(minutes);
        minutes = Math.max(0, Math.min(99, minutes));
        minutes = minutes.toString().padStart(2, '0');

        this.minutesCell0.textContent = minutes.charAt(0);
        this.minutesCell1.textContent = minutes.charAt(1);
    }

    beginCountdown() {
        clearInterval(this._updateInterval);
        this._updateInterval = setInterval(() => {
            if (this._time - 60 <= 0) {
                clearInterval(this._updateInterval);
                return;
            }

            this.setTime(this._time - 60);
        }, 60 * 1000);
    }
}
 c	      hThTHPh{   c    ~FETCH,:https://mega.io/wp-content/themes/megapages/megalib/js/megalib-components.js?ver=1746139693 strongly-framed 1 security-info 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 request-method GET response-head HTTP/2 200 
server: nginx
date: Thu, 19 Jun 2025 13:09:46 GMT
content-type: application/javascript
content-length: 53205
last-modified: Thu, 01 May 2025 22:48:13 GMT
etag: "6813fa2d-cfd5"
expires: Mon, 30 Jun 2025 23:13:59 GMT
cache-control: max-age=2592000, max-age=2592000
x-cache-status: HIT
accept-ranges: bytes
X-Firefox-Spdy: h2
 original-response-headers server: nginx
date: Thu, 19 Jun 2025 13:09:46 GMT
content-type: application/javascript
content-length: 53205
last-modified: Thu, 01 May 2025 22:48:13 GMT
etag: "6813fa2d-cfd5"
expires: Mon, 30 Jun 2025 23:13:59 GMT
cache-control: max-age=2592000
cache-control: max-age=2592000
x-cache-status: HIT
accept-ranges: bytes
X-Firefox-Spdy: h2
 ctid 2 uncompressed-len 0 net-response-time-onstart 1261 net-response-time-onstop 1262   